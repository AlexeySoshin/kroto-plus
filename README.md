# Kroto+ 
[![Build Status](https://travis-ci.org/marcoferrer/kroto-plus.svg?branch=master)](https://travis-ci.org/marcoferrer/kroto-plus)
[![GitHub license](https://img.shields.io/badge/license-Apache%20License%202.0-blue.svg?style=flat)](http://www.apache.org/licenses/LICENSE-2.0)

Kroto+ is a cli for generating Kotlin specific utility libraries for your Protobuf definitions.
It is comprised of modules that each generate use case specific code, allowing for a more idiomatic use of the classes generated by the ProtoC compiler. 


## Generators

### Stub Rpc Overloads Generator

This modules generates extension methods that overload the request message argument for rpc methods with a builder lambda block.

```kotlin
//Original
val response = serviceStub.myRpcMethod(ExampleServiceGrpc.MyRpcMethodRequest
                                   .newBuilder()
                                   .setId(100)
                                   .setName("some name")
                                   .build())
                                   
//Kroto+ Overloaded
val response = serviceStub.myRpcMethod{
                            id = 100
                            name = "some name"
                    }
```

This is what the code generated by Kroto+ looks like
```kotlin
//Future Stub
inline fun ExampleServiceFutureStub.myRpcMethod(block: ExampleServiceGrpc.MyRpcMethodRequest.Builder.() -> Unit): ListenableFuture<ExampleServiceGrpc.MyRpcMethodResponse> {
    val request = ExampleServiceGrpc.MyRpcMethodRequest.newBuilder().apply(block).build()
    return myRpcMethod(request)
}

//BlockingStub
inline fun ExampleServiceBlockingStub.myRpcMethod(block: ExampleServiceGrpc.MyRpcMethodRequest.Builder.() -> Unit): ExampleServiceGrpc.MyRpcMethodResponse {
    val request = ExampleServiceGrpc.MyRpcMethodRequest.newBuilder().apply(block).build()
    return myRpcMethod(request)
}
```

#### Coroutine Support
In addition to request message arguments as builder lambda rpc overloads, this module can also generate suspending overloads for rpc calls. 
1. This is accomplished by defining extension functions for async service stubs and combining a response observer with a coroutine builder.
2. This option requires the Kroto+ runtime to be included as a dependency. The runtime currently only consists of one file which provides the bridging support for response observer to coroutine.   
```kotlin
//Async Stub

suspend fun ExampleServiceStub.myRpcMethod(request: ExampleServiceGrpc.MyRpcMethodRequest): ExampleServiceGrpc.MyRpcMethodResponse = 
  suspendingAsyncUnaryCall(METHOD_MY_RPC_METHOD,channel,callOptions, request)

suspend inline fun ExampleServiceStub.myRpcMethod(block: ExampleServiceGrpc.MyRpcMethodRequest.Builder.() -> Unit): ExampleServiceGrpc.MyRpcMethodResponse {
    val request = ExampleServiceGrpc.MyRpcMethodRequest.newBuilder().apply(block).build()
    return myRpcMethod(request)
}
```

#### Current Limitations
1. Overloads are currently only being generated for unary rpc calls. Support for other rpc method types will be added in the future. 


### Mock Service Generator

This generator creates mock implementations of proto service definitions. This is useful for orchestrating a set of expected responses for unit testing methods that rely on rpc calls.
1. If no responses are added to the response queue then the mock service will return the default instance of the response type. 
 ```kotlin
@Test fun `Test Unary Response Queue`(){

    MockStandService.getStandByNameResponseQueue.apply {

        //Queue up a valid response message
        addMessage {
            name = "Star Platinum"
            powerLevel = 500
            speed = 550
            addAttacks(StandProtoBuilders.Attack {
                name = "ORA ORA ORA"
                damage = 100
                range = StandProto.Attack.Range.CLOSE
            })
        }

        //Queue up an error
        addError(Status.INVALID_ARGUMENT)
    }

    val standStub = StandServiceGrpc.newBlockingStub(grpcServerRule.channel)

    standStub.getStandByName { name = "Star Platinum" }.let{ response ->
        assertEquals("Star Platinum",response.name)
        assertEquals(500,response.powerLevel)
        assertEquals(550,response.speed)
        response.attacksList.first().let{ attack ->
            assertEquals("ORA ORA ORA",attack.name)
            assertEquals(100,attack.damage)
            assertEquals(StandProto.Attack.Range.CLOSE,attack.range)
        }
    }

    try{
        standStub.getStandByName { name = "The World" }
        fail("Exception was expected with status code: ${Status.INVALID_ARGUMENT.code}")
    }catch (e: StatusRuntimeException){
        assertEquals(Status.INVALID_ARGUMENT.code, e.status.code)
    }
}
```
### Message Builder Lambda Generator
This generator creates lambda based builders for message types
```kotlin
val attack = StandProtoBuilders.Attack {
                name = "ORA ORA ORA"
                damage = 100
                range = StandProto.Attack.Range.CLOSE
            }
```


## Gradle Plugin
Example gradle configuration
```groovy
buildscript{
    ext.krotoplusVersion

    dependencies{
        classpath "com.github.mferrer.krotoplus:kroto-plus-gradle-plugin:${krotoplusVersion}"
    }
}

krotoPlus{
    //Proto definition source directories, or path to jar containing proto definitions
    sources = [
        "$projectDir/src/main/proto",
        "$buildDir/extracted-include-protos/main"
    ]
    outputDir = "${protobuf.generatedFilesBaseDir}/main/kotlin"
}
```

## Road Map
1. Add cli support to compiler configuring generators
2. Update gradle plugin to support new compiler cli args 
2. Add support for generating overloads for streaming rpc calls.
5. Publish artifacts for runtime and runtime-test. 