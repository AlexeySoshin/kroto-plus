# Kroto+
[![Build Status](https://travis-ci.org/marcoferrer/kroto-plus.svg?branch=master)](https://travis-ci.org/marcoferrer/kroto-plus)

Kroto+ is a cli for generating Kotlin specific utility libraries for your Protobuf definitions.
It is comprised of modules that each generate use case specific code, allowing for a more idiomatic use of the classes generated by the ProtoC compiler. 


## Modules

### Stub Rpc Overloads

This modules generates extension methods that overload the request proto message argument for rpc methods with a builder lambda block.

```kotlin
//Original
val response = serviceStub.myRpcMethod(ExampleServiceGrpc.MyRpcMethodRequest
                                   .newBuilder()
                                   .setId(100)
                                   .setName("some name")
                                   .build())
                                   
//Kroto+ Overloaded
val response = serviceStub.myRpcMethod{
                            id = 100
                            name = "some name"
                    }
```

This is what the code generated by Kroto+ looks like
```kotlin
//Future Stub
inline fun ExampleServiceFutureStub.myRpcMethod(block: ExampleServiceGrpc.MyRpcMethodRequest.Builder.() -> Unit): ListenableFuture<ExampleServiceGrpc.MyRpcMethodResponse> {
    val request = ExampleServiceGrpc.MyRpcMethodRequest.newBuilder().apply(block).build()
    return myRpcMethod(request)
}

//BlockingStub
inline fun ExampleServiceBlockingStub.myRpcMethod(block: ExampleServiceGrpc.MyRpcMethodRequest.Builder.() -> Unit): ExampleServiceGrpc.MyRpcMethodResponse {
    val request = ExampleServiceGrpc.MyRpcMethodRequest.newBuilder().apply(block).build()
    return myRpcMethod(request)
}
```

#### Coroutine Support
In addition to builder lambda argument overloads, this module can also generate suspending overloads for rpc calls.
```kotlin
//Async Stub

suspend fun ExampleServiceStub.myRpcMethod(request: ExampleServiceGrpc.MyRpcMethodRequest): ExampleServiceGrpc.MyRpcMethodResponse = 
  suspendingAsyncUnaryCall(METHOD_MY_RPC_METHOD,channel,callOptions, request)

suspend inline fun ExampleServiceStub.myRpcMethod(block: ExampleServiceGrpc.MyRpcMethodRequest.Builder.() -> Unit): ExampleServiceGrpc.MyRpcMethodResponse {
    val request = ExampleServiceGrpc.MyRpcMethodRequest.newBuilder().apply(block).build()
    return myRpcMethod(request)
}
```

#### Current Limitations
1. Overloads are currently only being generated for unary rpc calls. Support for other rpc method types will be added in the future. 


### Mock Service Generator

This module generates mock implementations of proto service definitions. This is useful for orchestrating a set of expected responses for unit testing methods that rely on rpc calls.
1. If no responses are added to the response queue then the mock service will return the default instance of the response type. 
 ```kotlin
@Test fun `Test Unary Response Queue`(){

    MockStandService.getStandByNameResponseQueue.apply {

        //Queue up a valid response message
        addMessage {
            name = "Star Platinum"
            powerLevel = 500
            speed = 550
            addAttacks(StandProtoBuilders.Attack {
                name = "ORA ORA ORA"
                damage = 100
                range = StandProto.Attack.Range.CLOSE
            })
        }

        //Queue up an error
        addError(Status.INVALID_ARGUMENT)
    }

    val standStub = StandServiceGrpc.newBlockingStub(grpcServerRule.channel)

    standStub.getStandByName { name = "Star Platinum" }.let{ response ->
        assertEquals("Star Platinum",response.name)
        assertEquals(500,response.powerLevel)
        assertEquals(550,response.speed)
        response.attacksList.first().let{ attack ->
            assertEquals("ORA ORA ORA",attack.name)
            assertEquals(100,attack.damage)
            assertEquals(StandProto.Attack.Range.CLOSE,attack.range)
        }
    }

    try{
        standStub.getStandByName { name = "The World" }
        fail("Exception was expected with status code: ${Status.INVALID_ARGUMENT.code}")
    }catch (e: StatusRuntimeException){
        assertEquals(Status.INVALID_ARGUMENT.code, e.status.code)
    }
}
```

## Gradle Plugin
Example gradle configuration
```groovy
krotoPlus{
    //Proto definition source directories, or path to jar containing proto definitions
    sources = [
        "$projectDir/src/main/proto",
        "$buildDir/extracted-include-protos/main"
    ]
    outputDir = "${protobuf.generatedFilesBaseDir}/main/kotlin"
}
```

## Road Map
1. Gradle plugin for simplifying cli use.
2. Support for generating overloads for streaming rpc calls.
3. Builder lambda overloads for mock test ResponseQueue building.
4. Full example project (cli/gradle plugin).
5. Publish artifacts for runtime and runtime-test. 